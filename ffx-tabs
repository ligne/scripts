#!/usr/bin/env -S uv run -q --script
#
# Dump the tabs in a firefox session.
#
# /// script
# dependencies = [
#       "cattrs"
# ]
# ///
from __future__ import annotations

import json
import subprocess
import sys
from urllib.parse import ParseResult, urlparse

import cattrs
from attr import define, field


@define
class Entry:
    url: ParseResult = field(converter=urlparse)
    title: str


@define
class Tab:
    entries: list[Entry]
    lastAccessed: int
    hidden: bool
    userContextId: int
    attributes: dict
    index: int

    @property
    def url(self) -> str:
        return self.entries[self.index - 1].url

    @property
    def title(self) -> str:
        return self.entries[self.index - 1].title


@define
class Window:
    tabs: list[Tab]
    zIndex: int

    @property
    def tab_count(self) -> int:
        return len(self.tabs)


@define
class Session:
    windows: list[Window]

    @property
    def tab_count(self) -> int:
        return sum(w.tab_count for w in self.windows)


def format_url(url: ParseResult, fmt: str = "") -> str:
    try:
        return url.geturl() if fmt == "" else fmt.format(**url._asdict())
    except KeyError as e:
        available = ", ".join(url._asdict())
        print(f"Invalid field {e}. Available fields: {available}")
        exit()


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("filename")
    parser.add_argument("--format", default="")

    args = parser.parse_args()

    p = subprocess.run(["lz4jsoncat", args.filename], capture_output=True, encoding="utf8")
    session = json.loads(p.stdout)

    c = cattrs.Converter()
    session = c.structure(session, Session)

    for window in session.windows:
        print(f"Window {window.zIndex} ({window.tab_count} tabs)")
        for tab in window.tabs:
            print(format_url(tab.url, fmt=args.format))


# vim: ft=python : ts=4 : sw=4 : et
